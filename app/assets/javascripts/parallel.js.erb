//Place all the behaviors and hooks related to the matching controller here.
// All this logic will automatically be available in application.js.
// You can use CoffeeScript in this file: http://coffeescript.org/
var base_url_regions = "/assets/";

$(document).ready(function() {
	stats = Array();
	stats['boroughs'] = gon.feature_groups['boroughs'];
    stats['wards'] = gon.feature_groups['wards'];

	console.log(stats);

	if(gon.parallel)
        if(gon.para_boros)
		    setup_parallel_graph(stats['boroughs']);
        else
            setup_parallel_graph(stats['wards']);
	
})

function plot_parallel_data(stats)
{
	var svg = d3.select('#map').select('g');

}

function setup_parallel_graph(feat_list)
{
    var boroughs = [];
    var width = 1100,
    height = 400;

    var g;
    var line, axis, foreground;
    var svg;

    //Convert this into a JS object with a series of keypairs
    var factors = ["Crime Rate",
                    "House Price",
                    "GCSE Score",
                    "Transport Rating",
                    "School Absences",
                    "Income Support",
                    "Unemployment Rate",
                    "Dependent Children in Out-of-Work Household",
                    "Deliberate Fires",
                    "Incapacity Benefit"];
    //Define pixel widths across graph space
    //Top edge, right edge, bottom edge, left edge
    var m = [40, 40, 10, 40],
    w = width - m[1] - m[3],
    h = height - m[0] - m[2];

    //Define x scale
    var x = d3.scale.ordinal()
                    .domain(factors)
                    .rangePoints([0, w]),
        y = {};

    line = d3.svg.line();
    axis = d3.svg.axis().orient("left");

    //Create the svg base, translate according to coords
    console.log("w " + (w + m[1] + m[3]) + " h " + (h + m[0] + m[2]));
    d3.select("#parallel")
        .attr("width", width)
        .attr("height", height);

    svg = d3.select("#parallel").append("svg:svg")
                // .attr("width", w + m[1] + m[3])
                // .attr("height", h + m[0] + m[2])
                .append("svg:g")
                .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    // Create a scale and brush for each trait.
    //Trait being each variable, so for boros we do crime etc
    factors.forEach(function(factor_name) {
        // Coerce values to numbers.
        //This is a list of instances, so for us, boros
        feat_list.forEach(function(features) { 
            //var factor_id = get_factor_id(factor_name)
            //p[d] = +p[d]; 
            //feature['factors'][factor_id]
            //We might want to trim outliers here...
        });

        //Define y scale value based on attribute value
        //We need to replace the values in domain for the min/max of each
        //factor - to calc in ruby

        //Get scale for factor name
        var factor_id = get_factor_id(factor_name);
        var dom = [feat_list[0]['min_max'][factor_id]['min'], feat_list[0]['min_max'][factor_id]['max']]; 
        
        //Create the y-scale for this particular factor from height to 0 (we're in cartesian coords)
        y[factor_name] = d3.scale.linear()
                            .domain(d3.extent(dom))
                            .range([h, 0]);

        
        y[factor_name].brush = d3.svg.brush()
                                .y(y[factor_name])
                                .on("brush", brush);
    });

    // Add foreground lines.
    foreground = svg.append("svg:g")
                    .attr("class", "foreground")
                    .selectAll("path")
                    .data(feat_list, function(feature)
                    {
                        factors_vals = new(Array);

                        factors.forEach(function(factor){
                            factors_vals.push(feature['factors'][get_factor_id(factor)]);
                        })
                        return factors_vals;
                    })
                    .enter().append("svg:path")
                    .attr("d", path)
                    .attr("class", function(feature) 
                    {
                        return "line-l"
                    });


    // Add a group element for each trait.
    g = svg.selectAll(".factor")
                .data(factors)
                .enter().append("svg:g")
                .attr("class", "factor")
                .attr("transform", function(d) 
                {
                    console.log("here");
                    return "translate(" + x(d) + ")"; 
                })
                .call(d3.behavior.drag()
                    .origin(function(d) { 
                        return {
                            x: x(d)
                        }; 
                    })
                    .on("dragstart", dragstart)
                    .on("drag", drag)
                    .on("dragend", dragend)
                );

    // Add an axis and title.
    g.append("svg:g")
        .attr("class", "axis")
        .each(function(d) { 
            d3.select(this).call(axis.scale(y[d])); 
        })
        .append("foreignObject")
        .attr("text-anchor", "middle")
        .attr("y", -40)
        .attr("x", -40)
        .attr("width", 100)
        .attr("height", 40)
        .append("xhtml:p")
        .html(function(d){
            //Handle line splits properly
            if(d.length > 10)
            {
                var temp_end = d.slice(10);
                var parts = d.split(" ");
                var return_line = "";
                var current_line = parts[0];
                for(var i = 1; i < parts.length; i++)
                {
                    if(current_line.length > 10)
                    {
                        if(return_line.length > 0)
                            return_line += '<br/>';
                        return_line += current_line;
                        current_line = parts[i];
                    }
                    else
                        current_line += " " + parts[i];
                }
                if(current_line.length > 0)
                {
                    if(return_line.length > 0)
                        return_line += "<br/>";
                    return_line += current_line;
                }
                return return_line;
            }
            else
                return d;
        });

    // Add a brush for each axis.
    g.append("svg:g")
        .attr("class", "brush")
        .each(function(d) { 
            d3.select(this).call(y[d].brush); 
        })
        .selectAll("rect")
        .attr("x", -8)
        .attr("width", 16);
    //These functions allow you to define sections of the coordinates to

    function dragstart(d) {
        i = factors.indexOf(d);
        console.log(d);
    }

    function drag(d) {
        x.range()[i] = d3.event.x;
        factors.sort(function(a, b) { return x(a) - x(b); });
        g.attr("transform", function(d) { return "translate(" + x(d) + ")"; });
        foreground.attr("d", path);
    }

    function dragend(d) {
        x.domain(factors).rangePoints([0, w]);
        var t = d3.transition().duration(500);
        t.selectAll(".factor").attr("transform", function(d) { 
                return "translate(" + x(d) + ")"; 
            });
        t.selectAll(".foreground path").attr("d", path);
    }

    function get_factor_id(factor_name)
    {
        switch(factor_name)
        {
            case "Crime Rate":  return "crimeRate";  break;
            case "House Price":   return "housePrice"; break;
            case "GCSE Score":   return "GCSEScore"; break;
            case "Transport Rating":   return "transportRating"; break;
            case "School Absences":   return "schoolAbscences"; break;
            case "Income Support":   return "incomeSupport"; break;
            case "Unemployment Rate":   return "unemploymentRate"; break;
            case "Dependent Children in Out-of-Work Household":   return "childInNoWorkHouse"; break;
            case "Deliberate Fires":   return "deliberateFires"; break;
            case "Incapacity Benefit":   return "incapacityBenefit"; break;
        }
    }


    // Returns the path for a given data point.
    function path(data) {
        return line(factors.map(function(factor_name) 
        { 
            var factor_id = get_factor_id(factor_name);
            return [x(factor_name), y[factor_name](data['factors'][factor_id])]; 
        }));
    }

    // Handles a brush event, toggling the display of foreground lines.
    function brush() {
        var actives = factors.filter(function(p) { return !y[p].brush.empty(); }),
        extents = actives.map(function(p) { return y[p].brush.extent(); });
        foreground.classed("line-fade", function(d) 
        {
            return !actives.every(function(p, i) 
            {
                return extents[i][0] <= d[p] && d[p] <= extents[i][1];
            });
        });
    }
}


